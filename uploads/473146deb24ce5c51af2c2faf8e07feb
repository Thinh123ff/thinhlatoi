require('dotenv').config();
console.log("üîë BRAVE_API_KEY: ƒê√£ c·∫•u h√¨nh",);
const axios = require('axios');
const pdfParse = require('pdf-parse');
const mammoth = require('mammoth');
const csvParse = require('csv-parse/sync');
const { encode } = require('gpt-3-encoder');
const express = require('express');
const multer = require('multer');
const fs = require('fs');
const cors = require('cors');
const app = express();
const port = 5000;
const upload = multer({ dest: 'uploads/' });

app.use(cors({
    origin: [
        'http://localhost:63342',
        'http://127.0.0.1:5500',
        'http://localhost:5000',
        'https://thinhnt-mr.github.io',
    ]
}));
app.use(express.json());
app.use(express.static('public'));

const sessions = {};

function countTokensFromMessages(messages) {
    const flatContent = messages.map(msg => {
        if (typeof msg.content === 'string') return msg.content;
        if (Array.isArray(msg.content)) {
            return msg.content.map(item => item.text || '').join(' ');
        }
        return '';
    }).join(' ');
    return encode(flatContent).length;
}

function getOrCreateSession(sessionId) {
    if (!sessions[sessionId]) {
        sessions[sessionId] = {
            messages: [
                {
                    role: 'system',
                    content: `
B·∫°n l√† tr·ª£ l√Ω AI th√¥ng minh, lu√¥n tr·∫£ l·ªùi b·∫±ng **ti·∫øng Vi·ªát**, v·ªõi gi·ªçng vƒÉn **th√¢n thi·ªán, r√µ r√†ng, c√≥ tr√°ch nhi·ªám** v√† tr√¨nh b√†y **ƒë·∫πp b·∫±ng Markdown**.

### üéØ Y√™u c·∫ßu tr√¨nh b√†y t·ªïng qu√°t
- Tr√¨nh b√†y c√≥ c·∫•u tr√∫c: ti√™u ƒë·ªÅ ch√≠nh d√πng \`###\` ho·∫∑c **bold**.
- Khi c√≥ danh s√°ch m·ª•c, m√≥n ƒÉn, c√¥ng c·ª• ‚Üí d√πng icon ph√¢n lo·∫°i, v√≠ d·ª•:
  - üç≤ **Canh chua c√° l√≥c**
  - üíª **Visual Studio Code**
- S·ª≠ d·ª•ng:
  - **Danh s√°ch g·∫°ch ƒë·∫ßu d√≤ng** ƒë·ªÉ n√™u t·ª´ng √Ω.
  - **B·∫£ng Markdown** ƒë·ªÉ so s√°nh ho·∫∑c t·ªïng h·ª£p.
  - \`\`\`code block\`\`\` n·∫øu tr·∫£ l·ªùi c√≥ ƒëo·∫°n m√£.
- Cu·ªëi c√¢u tr·∫£ l·ªùi n√™n c√≥ üìå **T·ªïng k·∫øt**, ho·∫∑c ‚úÖ **G·ª£i √Ω ti·∫øp theo** n·∫øu ph√π h·ª£p.

### üçΩÔ∏è N·∫øu ng∆∞·ªùi d√πng h·ªèi v·ªÅ m√≥n ƒÉn / th·ª±c ƒë∆°n / n·∫•u n∆∞·ªõng:
- Tr√¨nh b√†y t·ª´ng m√≥n v·ªõi icon + ti√™u ƒë·ªÅ r√µ.
- V·ªõi m·ªói m√≥n:
  - **Nguy√™n li·ªáu** (in ƒë·∫≠m).
  - **C√°ch l√†m** (in ƒë·∫≠m).
  - C√≥ th·ªÉ th√™m ‚úÖ *L·ª£i √≠ch* n·∫øu ph√π h·ª£p.
- C√≥ th·ªÉ t·∫°o b·∫£ng t·ªïng k·∫øt v√≠ d·ª•:

| M√≥n ƒÉn | Lo·∫°i | ∆Øu ƒëi·ªÉm |
|--------|------|---------|
| ü•ó Salad g√† | M√≥n tr·ªôn | √çt calo, gi√†u protein |
| ü•£ S√∫p b√≠ ƒë·ªè | M√≥n canh | No l√¢u, d·ªÖ n·∫•u |

### üß† N·∫øu ng∆∞·ªùi d√πng h·ªèi v·ªÅ ki·∫øn th·ª©c, so s√°nh, ƒë√°nh gi√°:
- B·∫Øt ƒë·∫ßu b·∫±ng üîπ **Gi·∫£i th√≠ch**.
- ƒê∆∞a ra ‚úÖ **V√≠ d·ª• minh h·ªça**.
- K·∫øt th√∫c v·ªõi üìå **T·ªïng k·∫øt ng·∫Øn**.

### üîé N·∫øu ng∆∞·ªùi d√πng y√™u c·∫ßu t√¨m ki·∫øm web:
- Hi·ªÉn th·ªã m·ªói k·∫øt qu·∫£ g·ªìm:
  - ‚úÖ **T√™n** (bold).
  - üîó Link.
  - üìÑ M√¥ t·∫£ ng·∫Øn.
- C√≥ th·ªÉ d√πng b·∫£ng Markdown n·∫øu c√≥ t·ª´ 2 k·∫øt qu·∫£ tr·ªü l√™n.

### üìÅ N·∫øu ng∆∞·ªùi d√πng t·∫£i l√™n file ho·∫∑c ·∫£nh:
- ƒê·ªçc n·ªôi dung ‚Üí T√≥m t·∫Øt l·∫°i r√µ r√†ng.
- N·∫øu l√† file b√†i t·∫≠p / code ‚Üí Hi·ªÉu v√† gi·∫£i th√≠ch.
- N·∫øu ·∫£nh l√† giao di·ªán ho·∫∑c l·ªói ‚Üí ph√¢n t√≠ch giao di·ªán ho·∫∑c l·ªói, g·ª£i √Ω c·∫£i thi·ªán.

üìå Lu√¥n tr·∫£ l·ªùi c√≥ tr√°ch nhi·ªám, kh√¥ng n√≥i qua loa. N·∫øu thi·∫øu th√¥ng tin, h√£y h·ªèi l·∫°i ng∆∞·ªùi d√πng ƒë·ªÉ l√†m r√µ.
`
                }
            ],
            createdAt: new Date(),
            requestTimestamps: []
        };
    }
    return sessions[sessionId];
}

function cleanupSessions() {
    const now = new Date();
    Object.keys(sessions).forEach(id => {
        const session = sessions[id];
        const ageInHours = (now - new Date(session.createdAt)) / (1000 * 60 * 60);
        if (ageInHours > 24) {
            delete sessions[id];
        }
    });
}
setInterval(cleanupSessions, 1000 * 60 * 60);

app.post('/ask', upload.array('files'), async (req, res) => {
    const message = req.body.message || '';
    const files = req.files || [];
    const sessionId = req.body.sessionId || 'default';
    const content = [{ type: 'text', text: `\n${message}` }];

    let fullResponse = '';

    try {
        const session = getOrCreateSession(sessionId);
        // Gi·ªõi h·∫°n l∆∞·ª£t c√¢u h·ªèi/session: t·ªëi ƒëa 5 c√¢u
        const userQuestionCount = session.messages.filter(m => m.role === 'user').length;
        if (userQuestionCount >= 5) {
            return res.status(429).json({ reply: "B·∫°n ƒë√£ d√πng h·∫øt 5 l∆∞·ª£t trong h√¥m nay. Vui l√≤ng th·ª≠ l·∫°i sau." });
        }

        // Gi·ªõi h·∫°n request nhanh: t·ªëi ƒëa 5 request/ph√∫t
        const now = Date.now();
        session.requestTimestamps = session.requestTimestamps.filter(t => now - t < 60000);
        if (session.requestTimestamps.length >= 5) {
            return res.status(429).json({ reply: "‚è≥ B·∫°n ƒëang g·ª≠i qu√° nhanh. Vui l√≤ng ch·ªù 1 ph√∫t r·ªìi th·ª≠ l·∫°i." });
        }
        session.requestTimestamps.push(now);

        if (/t√¨m (tr√™n m·∫°ng|web|Google|Bing|internet|link t·∫£i|c√¥ng c·ª•|trang web|download)/i.test(message)) {
            const searchResult = await searchBrave(message);

            session.messages.push({
                role: 'assistant',
                content: `üì° **K·∫øt qu·∫£ t·ª´ Brave Search:**\n\n${searchResult}\n\nüëâ H√£y s·ª≠ d·ª•ng k·∫øt qu·∫£ n√†y ƒë·ªÉ h·ªó tr·ª£ tr·∫£ l·ªùi c√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng.`
            });
        }

        for (const file of files) {
            const buffer = fs.readFileSync(file.path);
            const mime = file.mimetype;
            const filename = file.originalname;

            try {
                if (mime === 'application/pdf') {
                    const pdfData = await pdfParse(buffer);
                    content.push({ type: 'text', text: `üìÑ ${filename}:\n\n${pdfData.text.slice(0, 5000)}` });
                } else if (mime === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {
                    const result = await mammoth.extractRawText({ buffer });
                    content.push({ type: 'text', text: `üìù ${filename}:\n\n${result.value.slice(0, 5000)}` });
                } else if (mime === 'text/csv') {
                    const csvText = buffer.toString('utf8');
                    const records = csvParse.parse(csvText, { columns: true });
                    const preview = JSON.stringify(records.slice(0, 3), null, 2);
                    content.push({ type: 'text', text: `üìä ${filename}:\n\n\`\`\`json\n${preview}\n\`\`\`` });
                } else if (mime.startsWith('image/')) {
                    const base64 = buffer.toString('base64');
                    content.push({ type: 'image_url', image_url: { url: `data:${mime};base64,${base64}`, detail: 'auto' } });
                } else if (mime.startsWith('audio/')) {
                    const audioPath = file.path;
                    const formData = new (require('form-data'))();
                    formData.append('file', fs.createReadStream(audioPath));
                    formData.append('model', 'whisper-1');

                    const whisperRes = await axios.post('https://api.openai.com/v1/audio/transcriptions', formData, {
                        headers: {
                            'Authorization': `Bearer ${process.env.OPENAI_API_KEY_1}`,
                            ...formData.getHeaders()
                        }
                    });

                    content.push({ type: 'text', text: `üéµ ${filename}:\n\n${whisperRes.data.text}` });
                } else {
                    content.push({ type: 'text', text: `üìé ${filename}` });
                }
            } catch (err) {
                content.push({ type: 'text', text: `‚ö†Ô∏è Kh√¥ng th·ªÉ x·ª≠ l√Ω file ${filename}` });
            }
        }

        let messageParts = [];

        for (const c of content) {
            if (c.type === 'text') {
                messageParts.push(c.text.trim());
            } else if (c.type === 'image_url') {
                messageParts.push({
                    type: 'image_url',
                    image_url: c.image_url
                });
            }
        }

        // N·∫øu c√≥ ·∫£nh ‚Üí gi·ªØ d·∫°ng structured array; n·∫øu ch·ªâ c√≥ text ‚Üí gh√©p chu·ªói
        let userMessage;
        if (messageParts.some(p => typeof p === 'object')) {
            userMessage = { role: 'user', content: messageParts };
        } else {
            userMessage = { role: 'user', content: messageParts.join('\n\n') };
        }

        session.messages.push(userMessage);

        const maxMessages = 6;
        if (session.messages.length > maxMessages) {
            const [systemMsg, ...rest] = session.messages;
            session.messages = [systemMsg, ...rest.slice(-maxMessages + 1)];
        }

        const tokenLimit = 10000;
        const promptTokens = countTokensFromMessages(session.messages);
        const safeMaxTokens = Math.min(4000, Math.max(800, tokenLimit - promptTokens));

        // T√≠nh l·∫°i Token
        const completionTokens = encode(fullResponse).length;
        console.log(`completionTokens: ${completionTokens}, totalTokens: ${promptTokens + completionTokens}`);

        console.log('ƒêang g·ª≠i y√™u c·∫ßu ƒë·∫øn OpenAI...');
        console.log(`promptTokens: ${promptTokens}, max_tokens: ${safeMaxTokens}`);
        console.log(`Session ${sessionId} c√≥ ${session.messages.length} tin nh·∫Øn`);

        let response;
        try {
            response = await sendToOpenAI(process.env.OPENAI_API_KEY_1, session.messages, safeMaxTokens);
        } catch (err) {
            if (err.response?.status === 429) {
                console.warn("‚ö†Ô∏è Key 1 b·ªã gi·ªõi h·∫°n, th·ª≠ d√πng Key 2...");
                try {
                    response = await sendToOpenAI(process.env.OPENAI_API_KEY_2, session.messages, safeMaxTokens);
                } catch (err2) {
                    console.error("üö´ Key 2 c≈©ng b·ªã l·ªói:", err2.response?.data || err2.message);
                    return res.status(500).json({ reply: "C·∫£ hai API key ƒë·ªÅu b·ªã gi·ªõi h·∫°n. Vui l√≤ng th·ª≠ l·∫°i sau v√†i ph√∫t." });
                }
            } else {
                throw err; // N·∫øu l·ªói kh√°c 429 ‚Üí n√©m ra ƒë·ªÉ x·ª≠ l√Ω nh∆∞ c≈©
            }
        }

        files.forEach(f => fs.unlinkSync(f.path));

        res.setHeader('Content-Type', 'text/event-stream');
        res.setHeader('Cache-Control', 'no-cache');
        res.setHeader('Connection', 'keep-alive');

        response.data.on('data', chunk => {
            const lines = chunk.toString().split('\n');
            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    const data = line.slice(6);
                    if (data === '[DONE]') {
                        res.write(`data: [DONE]\n\n`);
                        res.end();
                        session.messages.push({ role: 'assistant', content: fullResponse });
                        return;
                    }
                    try {
                        const parsed = JSON.parse(data);
                        const content = parsed.choices?.[0]?.delta?.content;
                        if (content) {
                            fullResponse += content;
                            res.write(`data: ${JSON.stringify({ content })}\n\n`);
                        }
                    } catch (e) {
                        console.error('L·ªói ph√¢n t√≠ch stream:', e);
                    }
                }
            }
        });

        response.data.on('error', err => {
            console.error('L·ªói stream:', err);
            res.status(500).json({ reply: "L·ªói khi nh·∫≠n ph·∫£n h·ªìi t·ª´ OpenAI" });
        });
    } catch (err) {
        console.error('L·ªói khi g·ªçi OpenAI:');
        if (err.response) {
            console.error('M√£ l·ªói:', err.response.status);
            console.error('D·ªØ li·ªáu l·ªói:', err.response.data);
            res.status(500).json({
                reply: `L·ªói t·ª´ OpenAI: ${err.response.data?.error?.message || 'Kh√¥ng x√°c ƒë·ªãnh'}`
            });
        } else if (err.request) {
            console.error('Kh√¥ng nh·∫≠n ƒë∆∞·ª£c ph·∫£n h·ªìi:', err.request);
            res.status(500).json({ reply: "Kh√¥ng nh·∫≠n ƒë∆∞·ª£c ph·∫£n h·ªìi t·ª´ OpenAI." });
        } else {
            console.error('L·ªói:', err.message);
            res.status(500).json({ reply: `L·ªói khi g·ª≠i y√™u c·∫ßu: ${err.message}` });
        }
    }
});

async function sendToOpenAI(apiKey, sessionMessages, maxTokens) {
    return await axios.post(
        'https://api.openai.com/v1/chat/completions',
        {
            model: 'gpt-4o',
            messages: sessionMessages,
            max_tokens: maxTokens,
            temperature: 0.7,
            stream: true
        },
        {
            headers: {
                'Authorization': `Bearer ${apiKey}`,
                'Content-Type': 'application/json'
            },
            responseType: 'stream',
            timeout: 120000
        }
    );
}
async function searchBrave(query) {
    const res = await axios.get('https://api.search.brave.com/res/v1/web/search', {
        headers: {
            'Accept': 'application/json',
            'X-Subscription-Token': process.env.BRAVE_API_KEY
        },
        params: {
            q: query,
            count: 3
        }
    });
    return res.data.web.results.map(r => `${r.title}\n${r.url}\n${r.description}`).join('\n\n');
}

// API l·∫•y l·ªãch s·ª≠ h·ªôi tho·∫°i
app.get('/conversation/:sessionId', (req, res) => {
    const sessionId = req.params.sessionId;
    const session = sessions[sessionId];

    if (!session) {
        return res.status(404).json({ error: 'Kh√¥ng t√¨m th·∫•y phi√™n h·ªôi tho·∫°i' });
    }

    // Ch·ªâ tr·∫£ v·ªÅ tin nh·∫Øn c·ªßa ng∆∞·ªùi d√πng v√† AI (kh√¥ng tr·∫£ v·ªÅ system message)
    const conversationHistory = session.messages.slice(1);
    res.json({ history: conversationHistory });
});

// API x√≥a h·ªôi tho·∫°i
app.delete('/conversation/:sessionId', (req, res) => {
    const sessionId = req.params.sessionId;
    if (sessions[sessionId]) {
        delete sessions[sessionId];
        res.json({ success: true, message: 'ƒê√£ x√≥a phi√™n h·ªôi tho·∫°i' });
    } else {
        res.status(404).json({ error: 'Kh√¥ng t√¨m th·∫•y phi√™n h·ªôi tho·∫°i' });
    }
});

app.get('/ping', (req, res) => {
    res.send('pong');
});

app.listen(port, () => {
    console.log(`Server ƒëang ch·∫°y t·∫°i http://localhost:${port}`);
    if (!process.env.OPENAI_API_KEY) {
        console.error('‚ö†Ô∏è OPENAI_API_KEY ch∆∞a ƒë∆∞·ª£c thi·∫øt l·∫≠p trong .env');
    } else {
        console.log('‚úÖ OPENAI_API_KEY ƒë√£ ƒë∆∞·ª£c c·∫•u h√¨nh.');
    }
});